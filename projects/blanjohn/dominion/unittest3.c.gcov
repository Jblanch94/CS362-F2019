        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <string.h>
        -:    6:#include <assert.h>
        -:    7:#include <stdlib.h>
        -:    8:#include <math.h>
        -:    9:
        -:   10:#define TESTCARD "Ambassador"
        -:   11:
function main called 1 returned 100% blocks executed 89%
        1:   12:int main() {
        -:   13:
        -:   14:	//set up state so game can be initialzed with parameters needed for minion function
        -:   15:    struct gameState G, testG;
        1:   16:    int seed = 1000;
        1:   17:    int numPlayers = 2;
        -:   18:    int choice1, choice2;
        1:   19:    int handPos = 0;
        -:   20:    int i;
        1:   21:    int currentPlayer = whoseTurn(&G);
call    0 returned 100%
        1:   22:    int k[10] = {adventurer, embargo, village, minion, mine, cutpurse, sea_hag, tribute, smithy, council_room}; 
        -:   23:
        -:   24:    //start game
        1:   25:    initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        -:   26:
        1:   27:    printf("-------------------------TESTING CARD: %s ------------------------\n", TESTCARD);
call    0 returned 100%
        -:   28:
        -:   29:    //test if ambassador card was discarded
        1:   30:    printf("TEST 1: check if Ambassador card was discarded.\n");
call    0 returned 100%
        -:   31:
        1:   32:    choice1 = 2;
        1:   33:    choice2 = 1;
        -:   34:
        1:   35:    memcpy(&testG, &G, sizeof(struct gameState));
        -:   36:
        1:   37:    ambassadorRefactored(choice1, choice2, &testG, handPos, currentPlayer);
call    0 returned 100%
        -:   38:
        1:   39:    int numCards = numHandCards(&testG);
call    0 returned 100%
        1:   40:   	int found = 0;
        -:   41:
        4:   42:   	for(i = 0; i < numCards; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        3:   43:   		if(testG.hand[currentPlayer][i] == ambassador) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   44:   			found = 1;
        -:   45:
        -:   46:   		}
        -:   47:   	}
        -:   48:
        1:   49:   	printf("Discard count: %d, expected discard count: %d\n", testG.discardCount[currentPlayer], G.discardCount[currentPlayer] + 1);
call    0 returned 100%
        -:   50:
        -:   51:   	//if found minion card then test failed otherwise it passed
        1:   52:   	if(found == 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   53:   		printf("Test failed for not discarding ambassador card after used.\n");
call    0 never executed
        -:   54:   	} else {
        1:   55:   		printf("Test passed for  discarding ambassador card after used.\n");
call    0 returned 100%
        -:   56:   	}
        -:   57:
        1:   58:   	printf("TEST 1 has completed.\n\n");
call    0 returned 100%
        -:   59:
        -:   60:
        -:   61:   	//check if both copies were placed in supply
        1:   62:   	printf("TEST 2: check if both copies were returned to supply.\n");
call    0 returned 100%
        -:   63:
        1:   64:   	memcpy(&testG, &G, sizeof(struct gameState));
        -:   65:
        1:   66:   	testG.hand[currentPlayer][0] = curse;
        1:   67:   	testG.hand[currentPlayer][2] = curse;
        1:   68:   	testG.hand[currentPlayer][4] = curse;
        -:   69:
        1:   70:   	testG.hand[currentPlayer + 1][0] = estate;
        1:   71:   	testG.hand[currentPlayer + 1][1] = copper;
        1:   72:   	testG.hand[currentPlayer + 1][2] = silver;
        1:   73:   	testG.hand[currentPlayer + 1][3] = gold;
        1:   74:   	testG.hand[currentPlayer + 1][4] = copper;
        -:   75:   	
        -:   76:
        1:   77:   	choice1 = 0;
        1:   78:   	choice2 = 2;
        -:   79:
        1:   80:   	ambassadorRefactored(choice1, choice2, &testG, handPos, currentPlayer);
call    0 returned 100%
        -:   81:
        1:   82:   	int count = 0;
        -:   83:
        1:   84:   	printf("supply count of curse cards: %d, expected supply count of cursed cards: %d\n", supplyCount(0, &testG), supplyCount(0, &G) + 2);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   85:
        -:   86:   	//since returning curse cards we want the supply count of curse to be two greater
        1:   87:   	if(supplyCount(0, &testG) == supplyCount(0, &G) + 2) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   88:   		printf("Test passed for adding two cards to supply count.\n");
call    0 never executed
        -:   89:   	} else {
        1:   90:   		printf("Test failed for not adding two cards to supply count.\n");
call    0 returned 100%
        -:   91:   	}
        -:   92:
        7:   93:   	for(i = 0; i < 6; i++) {
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        6:   94:   		if(testG.hand[currentPlayer][i] == curse) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        4:   95:   			count++;
        -:   96:   		}
        -:   97:   	}
        -:   98:
        1:   99:   	printf("Number of curse cards: %d, expected number of curse cards: %d\n", count, 0);
call    0 returned 100%
        -:  100:
        1:  101:   	if(count == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  102:   		printf("Test passed player who played card has no curse cards.\n");
call    0 never executed
        -:  103:   	} else {
        1:  104:   		printf("Test failed for player who played card having more than 0 curse cards.\n");
call    0 returned 100%
        -:  105:   	}
        -:  106:
        1:  107:   	count = 0;
        7:  108:   	for(i = 0; i < 6; i++) {
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        6:  109:   		if(testG.hand[currentPlayer + 1][i] == curse) {
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        1:  110:   			count++;
        -:  111:   		}
        -:  112:   	}
        -:  113:
        1:  114:   	printf("Number of curse cards: %d, Expected number of curse cards: %d\n", count, 1);
call    0 returned 100%
        -:  115:
        1:  116:   	if(count == 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  117:   		printf("Test passed where other players gain a copy of the card that was discarded.\n");
call    0 returned 100%
        -:  118:   	} else {
    #####:  119:   		printf("Test failed where other players don't gain a copy of the card that was discarded.\n");
call    0 never executed
        -:  120:   	}
        -:  121:
        1:  122:   	printf("TEST 2 has completed.\n\n");
call    0 returned 100%
        -:  123:
        -:  124:
        -:  125:   	//test to make sure if player who played card does not have enough copies that other players don't gain a copy
        1:  126:   	printf("TEST 3: check if player has no copies of card revealed that other players don't gain a copy.\n");
call    0 returned 100%
        -:  127:
        1:  128:   	memcpy(&testG, &G, sizeof(struct gameState));
        -:  129:
        1:  130:   	testG.hand[currentPlayer][0] = curse;
        1:  131:   	testG.hand[currentPlayer][1] = estate;
        1:  132:   	testG.hand[currentPlayer][2] = silver;
        1:  133:   	testG.hand[currentPlayer][3] = copper;
        1:  134:   	testG.hand[currentPlayer][4] = mine;
        -:  135:
        1:  136:   	testG.hand[currentPlayer + 1][0] = estate;
        1:  137:   	testG.hand[currentPlayer + 1][1] = copper;
        1:  138:   	testG.hand[currentPlayer + 1][2] = silver;
        1:  139:   	testG.hand[currentPlayer + 1][3] = gold;
        1:  140:   	testG.hand[currentPlayer + 1][4] = copper;
        -:  141:   	
        -:  142:
        1:  143:   	choice1 = 0;
        1:  144:   	choice2 = 0;
        -:  145:
        1:  146:   	ambassadorRefactored(choice1, choice2, &testG, handPos, currentPlayer);
call    0 returned 100%
        -:  147:
        1:  148:    count = 0;
        -:  149:
        1:  150:   	printf("supply count of curse cards: %d, expected supply count of cursed cards: %d\n", supplyCount(0, &testG), supplyCount(0, &G) + 2);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  151:
        1:  152:   	if(supplyCount(0, &testG) == supplyCount(0, &G)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  153:   		printf("Test passed for adding 0 cards to supply count.\n");
call    0 returned 100%
        -:  154:   	} else {
    #####:  155:   		printf("Test failed for not adding 0 cards to supply count.\n");
call    0 never executed
        -:  156:   	}
        -:  157:
        7:  158:   	for(i = 0; i < 6; i++) {
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        6:  159:   		if(testG.hand[currentPlayer][i] == curse) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        2:  160:   			count++;
        -:  161:   		}
        -:  162:   	}
        -:  163:
        1:  164:   	printf("Number of curse cards for player who played card: %d, expected number of curse cards for player who played card: %d\n", count, 1);
call    0 returned 100%
        -:  165:
        1:  166:   	if(count == 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  167:   		printf("Test passed has 1 curse cards.\n");
call    0 never executed
        -:  168:   	} else {
        1:  169:   		printf("Test failed for having curse not equal to one.\n");
call    0 returned 100%
        -:  170:   	}
        -:  171:
        1:  172:   	count = 0;
        7:  173:   	for(i = 0; i < 6; i++) {
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        6:  174:   		if(testG.hand[currentPlayer + 1][i] == curse) {
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        1:  175:   			count++;
        -:  176:   		}
        -:  177:   	}
        -:  178:
        1:  179:   	printf("Number of curse cards for next player: %d, Expected number of curse cards for next player: %d\n", count, 1);
call    0 returned 100%
        -:  180:
        1:  181:   	if(count == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  182:   		printf("Test passed where other players don't gain a copy of the card that was revealed.\n");
call    0 never executed
        -:  183:   	} else {
        1:  184:   		printf("Test failed where other players gain a copy of the card that was revealed.\n");
call    0 returned 100%
        -:  185:   	}
        -:  186:
        1:  187:   	printf("TEST 3 has completed.\n\n");
call    0 returned 100%
        -:  188:
        -:  189:   	//test if player tries to discard more than they should be allowed to
        1:  190:   	printf("TEST 4: testing for invalid number of cards to discard.\n");
call    0 returned 100%
        -:  191:
        1:  192:   	memcpy(&testG, &G, sizeof(struct gameState));
        -:  193:
        1:  194:   	currentPlayer = whoseTurn(&G);
call    0 returned 100%
        -:  195:
        1:  196:   	choice1 = 0;
        1:  197:   	choice2 = 3;
        -:  198:
        1:  199:   	testG.hand[currentPlayer][0] = copper;
        1:  200:   	testG.hand[currentPlayer][1] = copper;
        1:  201:   	testG.hand[currentPlayer][2] = copper;
        1:  202:   	testG.hand[currentPlayer][3] = copper;
        1:  203:   	testG.hand[currentPlayer][4] = copper;
        -:  204:
        1:  205:   	int status = ambassadorRefactored(choice1, choice2, &testG, handPos, currentPlayer);
call    0 returned 100%
        -:  206:
        1:  207:   	if(status == -1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  208:   		printf("Test passed for error checking on number of cards that can discarded.\n");
call    0 returned 100%
        -:  209:   	} else {
    #####:  210:   		printf("Test failed for allowing player to discard 3 cards when should only discard two cards.\n");
call    0 never executed
        -:  211:   	}
        -:  212:
        1:  213:   	printf("TEST 4 has completed.\n");
call    0 returned 100%
        -:  214:
        1:  215:   	return 0;
        -:  216:
        -:  217:}
