        -:    0:Source:unittest2.c
        -:    0:Graph:unittest2.gcno
        -:    0:Data:unittest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <string.h>
        -:    6:#include <assert.h>
        -:    7:#include <stdlib.h>
        -:    8:#include <math.h>
        -:    9:
        -:   10:#define TESTCARD "Minion"
        -:   11:
function main called 1 returned 100% blocks executed 87%
        1:   12:int main() {
        -:   13:
        -:   14:	//set up state so game can be initialzed with parameters needed for minion function
        -:   15:    struct gameState G, testG;
        1:   16:    int seed = 1000;
        1:   17:    int numPlayers = 2;
        -:   18:    int choice1, choice2;
        1:   19:    int handPos = 0;
        -:   20:    int i;
        1:   21:    int currentPlayer = whoseTurn(&G);
call    0 returned 100%
        1:   22:    int k[10] = {adventurer, embargo, village, minion, mine, cutpurse, sea_hag, tribute, smithy, council_room};    
        -:   23:
        -:   24:    //start game
        1:   25:    initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        -:   26:
        1:   27:    printf("-------------------------TESTING CARD: %s ------------------------\n", TESTCARD);
call    0 returned 100%
        -:   28:
        -:   29:    //test for +1 action
        1:   30:    printf("TEST 1: Check for +1 action.\n");
call    0 returned 100%
        -:   31:
        -:   32:    //copy state 
        1:   33:    memcpy(&testG, &G, sizeof(struct gameState));
        -:   34:
        -:   35:    //doesnt matter what choice is +1 action should happen regardless
        1:   36:    choice1 = 0;
        1:   37:    choice2 = 0;
        -:   38:
        -:   39:    //call function
        1:   40:    minionRefactored(choice1, choice2, &testG, handPos, currentPlayer);
call    0 returned 100%
        -:   41:
        -:   42:    //print num actions and expected
        1:   43:    printf("number of actions: %d, Expected number of actions: %d\n", testG.numActions, G.numActions + 1);
call    0 returned 100%
        -:   44:
        -:   45:    //test passed if added one action
        1:   46:    if(testG.numActions == G.numActions + 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   47:    	printf("Test passed checking for +1 action after minion card is played.\n");
call    0 never executed
        -:   48:    } else {
        1:   49:    	printf("Test failed checking for +1 action after minion card is played.\n");
call    0 returned 100%
        -:   50:    }
        -:   51:
        1:   52:    printf("TEST 1 has completed.\n\n");
call    0 returned 100%
        -:   53:
        -:   54:
        -:   55:    //test if choice1 = 1 then add 2 coins to player
        1:   56:    printf("TEST 2: choice1 = 1 +2 coins.\n");
call    0 returned 100%
        -:   57:
        1:   58:    memcpy(&testG, &G, sizeof(struct gameState));
        -:   59:
        1:   60:    choice1 = 1;
        -:   61:
        1:   62:   	minionRefactored(choice1, choice2, &testG, handPos, currentPlayer);
call    0 returned 100%
        -:   63:
        1:   64:   	printf("Number of coins: %d, Expected Number of coins: %d\n", testG.coins, G.coins + 2);
call    0 returned 100%
        1:   65:   	if(testG.coins == G.coins + 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   66:   		printf("Test passed adding two coins for first choice.\n");
call    0 returned 100%
        -:   67:   	} else {
    #####:   68:   		printf("Test failed for adding two coins for first choice.\n");
call    0 never executed
        -:   69:   	}
        -:   70:
        1:   71:   	printf("TEST 2 has completed.\n\n");
call    0 returned 100%
        -:   72:
        -:   73:   	//checks if the minion card was discarded and not any card from hand
        1:   74:   	printf("TEST 3: check if minion was discarded.\n");
call    0 returned 100%
        -:   75:
        1:   76:   	memcpy(&testG, &G, sizeof(struct gameState));
        -:   77:
        1:   78:   	minionRefactored(choice1, choice2, &testG, handPos, currentPlayer);
call    0 returned 100%
        -:   79:
        1:   80:   	int numCards = numHandCards(&testG);
call    0 returned 100%
        1:   81:   	int found = 0;
        -:   82:
        1:   83:   	printf("Number of cards in hand: %d, Expected number of cards in hand: %d\n", numCards, numHandCards(&G) - 1);
call    0 returned 100%
call    1 returned 100%
        -:   84:
        6:   85:   	for(i = 0; i < 5; i++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:   86:   		if(testG.hand[currentPlayer][i] == minion) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   87:   			found = 1;
        -:   88:
        -:   89:   		}
        -:   90:   	}
        -:   91:
        -:   92:   	//if found minion card then test failed otherwise it passed
        1:   93:   	if(found == 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   94:   		printf("Test failed for not discarding minion card after used.\n");
call    0 never executed
        -:   95:   	} else {
        1:   96:   		printf("Test passed for  discarding minion card after used.\n");
call    0 returned 100%
        -:   97:   	}
        -:   98:
        1:   99:   	printf("TEST 3 has completed.\n\n");
call    0 returned 100%
        -:  100:
        -:  101:   	//checks if hand is discarded and checks hand count afterwards
        1:  102:   	printf("TEST 4: choice2 = 1 check if hand is discarded and 4 new cards are drawn.\n");
call    0 returned 100%
        -:  103:
        1:  104:   	memcpy(&testG, &G, sizeof(struct gameState));
        -:  105:
        1:  106:   	choice1 = 0;
        1:  107:   	choice2 = 1;
        -:  108:
        1:  109:   	minionRefactored(choice1, choice2, &testG, handPos, currentPlayer);
call    0 returned 100%
        -:  110:
        -:  111:   	
        -:  112:   	// test if cards were discarded
        1:  113:   	if(testG.discardCount[currentPlayer] != G.discardCount[currentPlayer]) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  114:   		printf("Test failed did not discard hand and draw new cards.\n");
call    0 never executed
        -:  115:   	} else {
        1:  116:   		printf("Test passed did discard hand and draw new cards.\n");
call    0 returned 100%
        -:  117:   	}
        -:  118:
        -:  119:   	//test if four cards were drawn
        1:  120:   	printf("number of cards in hand: %d, expected number of cards in hand: %d\n", numHandCards(&testG), numHandCards(&G) - 1);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  121:
        -:  122:   	//passed if player has four cards
        1:  123:   	if(numHandCards(&testG) == numHandCards(&G) - 1) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  124:   		printf("Test passed with 4 cards in hand after redrawn.\n");
call    0 never executed
        -:  125:   	} else {
        1:  126:   		printf("Test failed with 4 cards not in hand after redrawn.\n");
call    0 returned 100%
        -:  127:   	}
        -:  128:
        1:  129:   	printf("TEST 4 has completed.\n\n");
call    0 returned 100%
        -:  130:
        -:  131:   	//same test as one above except for the next player
        -:  132:   	//only did it for next player since number of players is 2 but could have tested not matter the number of players
        1:  133:   	printf("TEST 5: choice2 = 1 check if hand is discarded and 4 cards redrawn for every  player.\n");
call    0 returned 100%
        -:  134:
        -:  135:
        1:  136:   	memcpy(&testG, &G, sizeof(struct gameState));
        -:  137:
        1:  138:   	currentPlayer = whoseTurn(&testG) + 1;
call    0 returned 100%
        -:  139:
        1:  140:   	minionRefactored(choice1, choice2, &testG, handPos, currentPlayer);
call    0 returned 100%
        -:  141:
        1:  142:   	if(testG.discardCount[currentPlayer] != G.discardCount[currentPlayer]) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  143:   		printf("Test failed did not discard hand and draw new cards.\n");
call    0 never executed
        -:  144:   	} else {
        1:  145:   		printf("Test passed did discard hand and draw new cards.\n");
call    0 returned 100%
        -:  146:   	}
        -:  147:
        1:  148:   	printf("number of cards in hand: %d, expected number of cards in hand: %d\n", numHandCards(&testG), numHandCards(&G) - 1);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  149:
        1:  150:   	if(numHandCards(&testG) == numHandCards(&G) - 1) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  151:		printf("Test passed player has 4 cards in hand.\n");
call    0 never executed
        -:  152:	} else {
        1:  153:		printf("Test failed player does not have 4 cards in hand.\n");
call    0 returned 100%
        -:  154:	}
        -:  155:
        1:  156:	printf("TEST 5 has completed.\n\n");
call    0 returned 100%
        -:  157:
        -:  158:   	
        -:  159:
        -:  160:
        1:  161:    return 0;
        -:  162:}
