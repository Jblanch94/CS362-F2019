        -:    0:Source:unittest5.c
        -:    0:Graph:unittest5.gcno
        -:    0:Data:unittest5.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <string.h>
        -:    6:#include <assert.h>
        -:    7:#include <stdlib.h>
        -:    8:#include <math.h>
        -:    9:
        -:   10:#define TESTCARD "Mine"
        -:   11:
function main called 1 returned 100% blocks executed 88%
        1:   12:int main ()
        -:   13:{
        -:   14:	//set up state so game can be initialzed with parameters needed for minion function
        -:   15:    struct gameState G, testG;
        1:   16:    int seed = 1000;
        1:   17:    int numPlayers = 2;
        -:   18:    int i;
        1:   19:    int found = 0;
        -:   20:    int status;
        1:   21:    int currentPlayer = whoseTurn(&G);
call    0 returned 100%
        1:   22:    int handPos = 0;
        1:   23:    int choice1 = 0;
        1:   24:    int choice2 = 0;
        1:   25:    int k[10] = {adventurer, embargo, village, minion, mine, cutpurse, sea_hag, tribute, smithy, council_room};   
        -:   26:
        -:   27:    //set up game
        1:   28:    initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        -:   29:
        1:   30:    printf("-------------------------TESTING CARD: %s ------------------------\n", TESTCARD);
call    0 returned 100%
        -:   31:
        1:   32:    memcpy(&testG, &G, sizeof(struct gameState));
        -:   33:
        -:   34:    //test to make sure mine card was discarded
        1:   35:    printf("TEST 1: check if mine card was discarded.\n");
call    0 returned 100%
        -:   36:
        1:   37:    mineRefactored(choice1, choice2, &testG, currentPlayer, handPos);
call    0 returned 100%
        -:   38:
        6:   39:    for(i = 0; i < numHandCards(&testG); i++)
call    0 returned 100%
branch  1 taken 83%
branch  2 taken 17% (fallthrough)
        -:   40:    {
        5:   41:    	if(testG.hand[currentPlayer][i] == mine)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   42:    	{
    #####:   43:    		found = 1;
        -:   44:    	}
        -:   45:    }
        -:   46:
        1:   47:    if(found == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   48:    {
    #####:   49:    	printf("Test passed for discarding mine card.\n");
call    0 never executed
        -:   50:    } 
        -:   51:
        -:   52:    else 
        -:   53:    {
        1:   54:    	printf("Test failed for not discarding mine card.\n");
call    0 returned 100%
        -:   55:    }
        -:   56:
        1:   57:    printf("TEST 1 has completed.\n\n");
call    0 returned 100%
        -:   58:
        -:   59:    //test that player gains a treasure card up to +3 of the one discarded
        1:   60:    printf("TEST 2: check if player gains a treasure card up to +3.\n");
call    0 returned 100%
        -:   61:
        1:   62:    memcpy(&testG, &G, sizeof(struct gameState));
        -:   63:
        1:   64:    testG.hand[currentPlayer][0] = copper;
        1:   65:    testG.hand[currentPlayer][1] = estate;
        1:   66:    testG.hand[currentPlayer][2] = mine;
        1:   67:    testG.hand[currentPlayer][3] = duchy;
        1:   68:    testG.hand[currentPlayer][4] = curse;   
        -:   69:
        1:   70:    choice1 = 0;
        1:   71:    choice2 = silver;
        1:   72:    found = 0;
        -:   73:
        1:   74:    mineRefactored(choice1, choice2, &testG, currentPlayer, handPos);
call    0 returned 100%
        -:   75:
        6:   76:    for(i = 0; i < numHandCards(&testG); i++)
call    0 returned 100%
branch  1 taken 83%
branch  2 taken 17% (fallthrough)
        -:   77:    {
        5:   78:    	if(testG.hand[currentPlayer][i] == silver)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -:   79:    	{
        1:   80:    		found = 1;
        -:   81:    	}
        -:   82:    }
        -:   83:
        1:   84:    if(found == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   85:    {
        1:   86:    	printf("Test passed for adding treasure card up to +3 of the one discarded.\n");
call    0 returned 100%
        -:   87:    }
        -:   88:
        -:   89:    else
        -:   90:    {
    #####:   91:    	printf("Test failed for not adding treasure card up to +3 of the one discarded.\n");
call    0 never executed
        -:   92:    }
        -:   93:
        1:   94:    printf("TEST 2 has completed.\n\n");
call    0 returned 100%
        -:   95:
        -:   96:    //test if card selected is more than +3 than card discarded will be allowed or not
        1:   97:    printf("TEST 3: check if card more than +3 will not be allowed.\n");
call    0 returned 100%
        -:   98:
        1:   99:    memcpy(&testG, &G, sizeof(struct gameState));
        -:  100:
        1:  101:    testG.hand[currentPlayer][0] = copper;
        1:  102:    testG.hand[currentPlayer][1] = estate;
        1:  103:    testG.hand[currentPlayer][2] = mine;
        1:  104:    testG.hand[currentPlayer][3] = duchy;
        1:  105:    testG.hand[currentPlayer][4] = curse; 
        -:  106:
        1:  107:    choice1 = 0;
        1:  108:    choice2 = gold;
        -:  109:
        1:  110:    mineRefactored(choice1, choice2, &testG, currentPlayer, handPos);
call    0 returned 100%
        -:  111:
        6:  112:   	for(i = 0; i < numHandCards(&testG); i++)
call    0 returned 100%
branch  1 taken 83%
branch  2 taken 17% (fallthrough)
        -:  113:   	{
        5:  114:   		if(testG.hand[currentPlayer][i] == gold)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -:  115:   		{
        1:  116:   			found = 1;
        -:  117:   		}
        -:  118:   	}
        -:  119:
        1:  120:   	if(found == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  121:   	{
        1:  122:   		printf("Test failed for adding treasure card that is +3 more than card discarded.\n");
call    0 returned 100%
        -:  123:   	}
        -:  124:
        -:  125:   	else 
        -:  126:   	{
    #####:  127:   		printf("Test passed for not adding treasure card that is +3 more than card discarded.\n");
call    0 never executed
        -:  128:   	}
        -:  129:
        1:  130:   	printf("TEST 3 has completed.\n\n");
call    0 returned 100%
        -:  131:
        -:  132:   	//test if selected treasure card was trashed
        1:  133:   	printf("TEST 4: check if treasure card selected was discarded.\n");
call    0 returned 100%
        -:  134:
        1:  135:   	memcpy(&testG, &G, sizeof(struct gameState));
        -:  136:
        1:  137:   	testG.hand[currentPlayer][0] = copper;
        1:  138:    testG.hand[currentPlayer][1] = estate;
        1:  139:    testG.hand[currentPlayer][2] = mine;
        1:  140:    testG.hand[currentPlayer][3] = duchy;
        1:  141:    testG.hand[currentPlayer][4] = curse; 
        -:  142:
        1:  143:   	choice1 = 0;
        1:  144:   	choice2 = silver;
        1:  145:   	found = 0;
        -:  146:
        1:  147:   	mineRefactored(choice1, choice2, &testG, currentPlayer, handPos);
call    0 returned 100%
        -:  148:
        -:  149:
        6:  150:   	for(i = 0; i < numHandCards(&testG); i++)
call    0 returned 100%
branch  1 taken 83%
branch  2 taken 17% (fallthrough)
        -:  151:   	{
        5:  152:   		if(testG.hand[currentPlayer][i] == copper)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  153:   		{
    #####:  154:   			found = 1;
        -:  155:   		}
        -:  156:   	}
        -:  157:
        1:  158:   	if(found == 0 && (testG.discardCount[currentPlayer] == G.discardCount[currentPlayer] + 1))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  159:   	{
    #####:  160:   		printf("Test passed for trashing selected treasure card.\n");
call    0 never executed
        -:  161:   	}
        -:  162:
        -:  163:   	else 
        -:  164:   	{
        1:  165:   		printf("Test failed for not trashing selected trasure card.\n");
call    0 returned 100%
        -:  166:   	}
        -:  167:
        -:  168:
        1:  169:   	printf("TEST 4 has completed.\n\n");
call    0 returned 100%
        -:  170:
        -:  171:   	//test for error checking if the selected was not between copper and gold
        1:  172:   	printf("TEST 5: check if a card selected is not between copper and gold.\n");
call    0 returned 100%
        -:  173:
        1:  174:   	memcpy(&testG, &G, sizeof(struct gameState));
        -:  175:
        1:  176:   	testG.hand[currentPlayer][0] = copper;
        1:  177:    testG.hand[currentPlayer][1] = estate;
        1:  178:    testG.hand[currentPlayer][2] = mine;
        1:  179:    testG.hand[currentPlayer][3] = duchy;
        1:  180:    testG.hand[currentPlayer][4] = curse; 
        -:  181:
        1:  182:   	choice1 = curse;
        1:  183:   	choice2 = silver;
        1:  184:   	found = 0;
        -:  185:
        1:  186:   	status = mineRefactored(choice1, choice2, &testG, currentPlayer, handPos);
call    0 returned 100%
        -:  187:
        1:  188:   	if(status == -1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  189:   	{
    #####:  190:   		printf("Test passed for not allowing a choice that is not between copper and gold.\n");
call    0 never executed
        -:  191:   	}
        -:  192:
        -:  193:   	else
        -:  194:   	{
        1:  195:   		printf("Test failed for allowing a choice that is not between copper and gold.\n");
call    0 returned 100%
        -:  196:   	}
        -:  197:
        1:  198:   	printf("TEST 5 has completed.\n\n");
call    0 returned 100%
        -:  199:
        -:  200:   	//test if invalid card choice, i.e. does not exist throws error or not
        1:  201:   	printf("TEST 6: check if invalid choice throws error.\n");
call    0 returned 100%
        -:  202:
        1:  203:   	memcpy(&testG, &G, sizeof(struct gameState));
        -:  204:
        1:  205:   	choice1 = copper;
        1:  206:   	choice2 = 100;
        1:  207:   	found = 0;
        -:  208:
        1:  209:   	status = mineRefactored(choice1, choice2, &testG, currentPlayer, handPos);
call    0 returned 100%
        -:  210:
        1:  211:   	if(status == -1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  212:   	{
        1:  213:   		printf("Test passed for not allowing an invalid choice to pass.\n");
call    0 returned 100%
        -:  214:   	}
        -:  215:
        -:  216:   	else
        -:  217:   	{
    #####:  218:   		printf("Test failed for not throwing error for invalid choice.\n");
call    0 never executed
        -:  219:   	}
        -:  220:
        1:  221:   	printf("TEST 6 has completed.\n\n");
call    0 returned 100%
        -:  222:
        -:  223:
        1:  224:    return 0;
        -:  225:}
