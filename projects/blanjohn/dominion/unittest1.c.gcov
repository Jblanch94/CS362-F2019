        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <string.h>
        -:    6:#include <assert.h>
        -:    7:#include <stdlib.h>
        -:    8:#include <math.h>
        -:    9:
        -:   10:#define TESTCARD "Baron"
        -:   11:
function main called 1 returned 100% blocks executed 79%
        1:   12:int main() {
        -:   13:
        -:   14:	//define states and initialize game
        -:   15:	struct gameState G, testG;
        1:   16:	int seed = 1000;
        1:   17:	int numPlayers = 2;
        1:   18:	int choice1 = 1;
        1:   19:	int currentPlayer = whoseTurn(&G);
call    0 returned 100%
        1:   20:	int k[10] = {adventurer, embargo, village, minion, mine, cutpurse, sea_hag, tribute, smithy, council_room};
        -:   21:
        -:   22:	//initialize game state and player cards
        1:   23:	initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        -:   24:
        1:   25:	printf("-------------------------TESTING CARD: %s ------------------------\n", TESTCARD);
call    0 returned 100%
        -:   26:
        -:   27:	//check if the number of buys were increased
        1:   28:	printf("TEST 1: Check for +1 buy\n");
call    0 returned 100%
        1:   29:	printf("---------------------------------------------------------------------\n");
call    0 returned 100%
        -:   30:
        1:   31:	memcpy(&testG, &G, sizeof(struct gameState));
        -:   32:
        -:   33:
        -:   34:	//after the expected should be 2
        1:   35:	int expectedNumBuys = 2;
        -:   36:
        -:   37:	//call baron function
        1:   38:	baronRefactored(choice1, &testG, currentPlayer);
call    0 returned 100%
        -:   39:
        -:   40:	//print the actual number of buys and the expected number of buys
        1:   41:	printf("num buys: %d, expected num buys: %d\n", testG.numBuys, expectedNumBuys);
call    0 returned 100%
        -:   42:
        -:   43:	//print if the test passed or failed
        1:   44:	if(testG.numBuys == expectedNumBuys) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:		printf("Test passed for increasing number of buys\n");
call    0 never executed
        -:   46:	} else {
        1:   47:		printf("Test failed for increasing number of buys\n");
call    0 returned 100%
        -:   48:	}
        1:   49:	printf("----------------------------------------------------------------------\n");
call    0 returned 100%
        -:   50:
        -:   51:	/*set choice to 1 anything over 0 
        -:   52:	check to make sure 4 coins are increased if estate is discarded 
        -:   53:	check to make sure estate is discarded */
        1:   54:	printf("TEST 2: choice1 = 1 -> discard estate and check number of coins increased by 4\n");
call    0 returned 100%
        -:   55:
        -:   56:	//copy state over for another test
        1:   57:	memcpy(&testG, &G, sizeof(struct gameState));
        1:   58:	choice1 = 1;
        1:   59:	int coinsAdded = 4;
        1:   60:	int handCards = numHandCards(&testG);
call    0 returned 100%
        -:   61:	int i;
        1:   62:	int found = 0;
        -:   63:
        -:   64:	//since testing for discarding estate make sure estate card is in hand
        1:   65:	testG.hand[currentPlayer][2] = estate;
        -:   66:
        1:   67:	baronRefactored(choice1, &testG, currentPlayer);
call    0 returned 100%
        -:   68:
        -:   69:	//find estate card in hand test for number of coins and number of cards in hand 
        6:   70:	for(i = 0; i < handCards; i++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:   71:		if(testG.hand[currentPlayer][i] == estate) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   72:			found = 1;
        -:   73:
        -:   74:			//testing to see if coins are added to player
    #####:   75:			printf("Found estate card and will be adding 4 coins to player.\n");
call    0 never executed
    #####:   76:			printf("number of coins: %d, expected number of coins: %d\n",testG.coins, G.coins + coinsAdded);
call    0 never executed
        -:   77:
    #####:   78:			if(testG.coins == G.coins + coinsAdded) {
branch  0 never executed
branch  1 never executed
    #####:   79:				printf("Test passed for adding 4 coins to player.\n");
call    0 never executed
        -:   80:			} else {
    #####:   81:				printf("Test failed for adding 4 coins to player.\n");
call    0 never executed
        -:   82:			}
        -:   83:
        -:   84:		}
        -:   85:	}
        -:   86:
        -:   87:
        1:   88:	printf("----------------------------------------------------------------------\n");
call    0 returned 100%
        -:   89:
        -:   90:	//test if no estate card found then no coins should be give to player and no card should be discarded
        1:   91:	printf("TEST 3: choice1 = 1 -> if no estate there is no coins added to player and no card should be discarded\n");
call    0 returned 100%
        -:   92:
        1:   93:	memcpy(&testG, &G, sizeof(struct gameState));
        -:   94:
        -:   95:	//since we dont want estate in hand make sure it is not
        1:   96:	testG.hand[currentPlayer][0] = minion;
        1:   97:	testG.hand[currentPlayer][1] = baron;
        1:   98:	testG.hand[currentPlayer][2] = mine;
        1:   99:	testG.hand[currentPlayer][3] = copper;
        1:  100:	testG.hand[currentPlayer][4] = silver;
        -:  101:
        -:  102:
        1:  103:	baronRefactored(choice1, &testG, currentPlayer);
call    0 returned 100%
        -:  104:
        1:  105:	found = 0;
        -:  106:
        6:  107:	for(i = 0; i < numHandCards(&testG); i++) {
call    0 returned 100%
branch  1 taken 83%
branch  2 taken 17% (fallthrough)
        5:  108:		if(testG.hand[currentPlayer][i] == estate) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  109:			found = 1;
        -:  110:		}
        -:  111:	}
        -:  112:
        -:  113:	//test for coins and cards in hand when no estate in hand
        1:  114:	if(found == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  115:		printf("number of coins: %d, expected number of coins: %d\n", testG.coins, G.coins);
call    0 returned 100%
        1:  116:		if(testG.coins == G.coins) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  117:			printf("Test passed for adding 0 coins to player when no estate card was found.\n");
call    0 returned 100%
    #####:  118:		} else if(testG.coins == G.coins + 4) {
branch  0 never executed
branch  1 never executed
    #####:  119:			printf("Test failed for adding 4 coins to player when no estate card was found.\n");
call    0 never executed
        -:  120:		}
        -:  121:
        1:  122:		printf("Hand count: %d, expected Hand count: %d\n", numHandCards(&testG), numHandCards(&G));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        1:  123:		if(numHandCards(&testG) == numHandCards(&G)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  124:			printf("Test passed for not discarding estate card when it was not found.\n");
call    0 returned 100%
    #####:  125:		} else if(numHandCards(&testG) == numHandCards(&G)  + 1) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  126:			printf("Test failed.\n");
call    0 never executed
        -:  127:		}
        -:  128:	}
        -:  129:
        -:  130:
        1:  131:	printf("----------------------------------------------------------------------\n");
call    0 returned 100%
        -:  132:
        -:  133:	//test for gain in estate card and decrease in supply count of estate cards
        1:  134:	printf("TEST 4: choice1 = 0 -> check for gain in estate card and decrease in supply count of estate cards.\n");
call    0 returned 100%
        1:  135:	printf("----------------------------------------------------------------------\n");
call    0 returned 100%
        -:  136:
        1:  137:	memcpy(&testG, &G, sizeof(struct gameState));
        1:  138:	found = 0;	
        1:  139:	choice1 = 0;
        1:  140:	int count = 0;
        1:  141:	baronRefactored(choice1, &testG, currentPlayer);
call    0 returned 100%
        -:  142:
        -:  143:	//get number of cards in hand
        1:  144:	handCards = numHandCards(&testG);
call    0 returned 100%
        -:  145:
        -:  146:	//test for adding estate card to hand and get number of cards in hand
        6:  147:	for(i = 0; i < handCards; i++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:  148:		if(testG.hand[currentPlayer][i] == estate) {
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        1:  149:			count++;
        -:  150:		}
        -:  151:	}
        -:  152:
        1:  153:	if(count == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  154:	{
        1:  155:		printf("Test passed for adding estate to player's hand.\n");
call    0 returned 100%
        -:  156:	}
        -:  157:
        -:  158:	else 
        -:  159:	{
    #####:  160:		printf("Test failed for not adding estate to player's hand.\n");
call    0 never executed
        -:  161:	}
        -:  162:
        -:  163:	//check to see if estate supply count was decremented
        1:  164:	printf("Estate supply count: %d, expected Estate supply count: %d\n", testG.supplyCount[estate], G.supplyCount[estate] - 1);
call    0 returned 100%
        1:  165:	if(testG.supplyCount[estate] == G.supplyCount[estate] - 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  166:		printf("Test passed for taking one estate card away from estate supply count.\n");
call    0 never executed
        -:  167:	} else {
        1:  168:		printf("Test failed .\n");
call    0 returned 100%
        -:  169:	}
        -:  170:
        1:  171:	printf("TEST 4 has completed.\n\n");
call    0 returned 100%
        -:  172:
        1:  173:	printf("TEST 5: check if baron card was discarded.\n");
call    0 returned 100%
        -:  174:
        1:  175:	memcpy(&testG, &G, sizeof(struct gameState));
        -:  176:
        1:  177:	choice1 = 0;
        1:  178:	found = 0;
        -:  179:
        1:  180:	baronRefactored(choice1, &testG, currentPlayer);
call    0 returned 100%
        -:  181:
        6:  182:	for(i = 0; i < numHandCards(&testG); i++)
call    0 returned 100%
branch  1 taken 83%
branch  2 taken 17% (fallthrough)
        -:  183:	{
        5:  184:		if(testG.hand[currentPlayer][i] == baron)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  185:		{
    #####:  186:			found = 1;
        -:  187:		}
        -:  188:	}
        -:  189:
        1:  190:	if(found == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  191:	{
    #####:  192:		printf("Test failed for not discarding baron card after use.\n");
call    0 never executed
        -:  193:	}
        -:  194:
        -:  195:	else
        -:  196:	{
        1:  197:		printf("Test passed for discarding baron card after use.\n");
call    0 returned 100%
        -:  198:	}
        -:  199:
        -:  200:
        1:  201:	printf("--------------------------TESTING COMPLETE-----------------------------------------------------------\n");
call    0 returned 100%
        -:  202:
        -:  203:
        1:  204:	return 0;
        -:  205:}
